git
______________________________________________________________________________________________________________________________________________________________

right click on folder, git bash here - sets up git window at location

touch app.html - creates html doc at locaiton

git init - creates a git repository at the location

$ git config --global user.name 'Will Jantscher'

$ git config --global user.email 'william.jantscher@gmail.com'

git add index.html - adds file to git repository

git status - show what is in the staging area

git add *.html - adds all html files to staging area

git add . - adds all files to staging area

git commit - commit files

$ git commit -m 'changed app.js' - includes comment in the command

$ touch .gitignore - which files for git to ignore, just put file names in here.

$ git branch login - adds a new branch

git checkout login - switch to login branch

git push - pushes everything to github

git pull - pulls from github

10/19/20______________________________________________________________________________________________________________________________________________________________

Pair Programming

pair programming - An Extreme Programming practice in which two engineers participate in one development effort at one workstation. Each member performs the action the other is not currently doing: While one types in Unit Tests the other thinks about the class that will satisfy the test, for example.
the programmer at the keyboard - the driver
the other focused on overall direction is the navigator
swap roles every few minutes or so 

why write in pairs?
code quality
Bus effect - if someone leaves from the project, the other can continue the project
transfer of knowledge - senior and junior (experience)
fewer bugs 
culture change

navigator
keeps big picture in mind
knows where you are going
gives high or mid-level instructions
not describing syntax

driver
writes the code
proving/disproving theories by testing 
asking questions

pairing technique is influenced by skill levels
narrow - ping pong/ take turns often
both: values of respect and communication
wide - more experienced dev should spend more time navigating

establish a good flow
when do we switch? set a timer, natural breaks (commit/push, lunch), one pair is getting frustrated/disengaged
ask to vocalize thoughts, increase wait time, be patient, don't type until you vocalize
use feedback - kind, actionable, specific, consensual
key - engagement - do what works for your pair

45 minutes in code wars
until 11:30 
Peter Vayda at LA AFB pairing partner - experience in js and coding

As a Senior Developer working with a Junior Developer, your job is to teach and mentor. In this scenario, the goal is not to get things done as quickly as possible, but instead to make sure the Junior developer is aware of what is happening.
As a Junior Developer working with someone more experienced, your top priority is to learn. The best method of learning is by doing, so try to do most of the typing.

pair feedback - Through constant feedback about their previous efforts, teams can identify areas for improvement and revise their practices. Feedback also supports simple design. Your team builds something, gathers feedback on your design and implementation, and then adjust your product going forward.

______________________________________________________________________________________________________________________________________________________________
JavaScript fundamentals
ES6 - Modern JavaScript, released 2015

destructuring objects (good for large objects)
{} is an object

var user = {
    first: 'benji',
    last: 'marinacci'
};

var first = user.first
var last = user.last; //old structure

var {first, last) = user}; //new structure

first; //=> benji

spread operator
use if we don't know how many arguments will be coming in

arrow function expression (es6 syntax)
const someNewFunction = () => {
    console.log('something')
}

default parameters
in function, set the default for something so if it not assigned it will have initial values
function someNewFunction(greeting = 'hi') {
    return greeting //doew not return undefined since greeting is defined in the function
}

//template literals 
function someNewFunction(greeting, name) {
    return greeting + ' ' + name + '!welcome to our website'
    return `${greeting} ${name}! Welcome to our website`
}

someNewFunction('sup', 'dog')


for...of Loop

var nums = [1, 4, 6, 7];

for (var val of nums) {
    console.log(val);
    //console.log(nums.indexOf(val));
}

let, const, var

var - sets a variable, can be reassigned/changed (global/function scoped) (can be outside of if/for/while loops)
const - cannot be reassigned, but it can be changed/modified (example, add to)
let - can be updated but not redeclared, block scoped (only available inside the scope it's declared ex. in for loop)
block has {}


explicit return
const canDrive = (person) => {
  if (person.age > 15) {
    return true
  } else {
    return false
  }
}

implicit return
const canDrive = person =>
  person.age > 15


const createProject = (name) => ({name})

spread operator/clone/delete/modify properties


let updateAge = (object, age) => {
    const output = {
        ...object,
        age: age,
    }
    return output;
}

let printArgs = (...args) => {
    //print all arguments, unkown ammount, want them in an object
    return args;
}
//NOTE - this returns averything as an array

function address({street, city, state, zip}) {
  return `${street}, ${city}, ${state} ${zip}`
}


scopes and closures---------------------------------------------------------------------------------------------
scope - reference to where values, objects and functions can be accessed
global scope: includes variables declared outside of a function
local scope: includes variables declared inside of a function
function- variables declared in function are only visible within the function block
block - {}
code - the code inside the current block

try to minimize global variables
return function (){} inside of a function  is not calling the function
can execute both functions if you do function()() or if you do newFunction = function ();

closures
closure - where an inner function has access to the outer (enclosed) functions variables, this creates a scope chain
scope chains have access to its own scope, access to its outer functions variables, and access to global scope variables
lexical scope: a variable defined outside of a function can be accessible inside of another function defined after variable declaration

return innerFunc; //if not called, will read out [Function: innerFunc]

function outerFunc() {
  let outerVar = 'I am ouside!';

  function innerFunc() {
    var name = 'poli';
    console.log(name);
    console.log(outerVar);
  }
  console.log(outerVar);
  return innerFunc;
};

// outerFunc();
var myInnerFunc = outerFunc();
myInnerFunc();

closure stuff
Here's a slightly more interesting exampleâ€”a makeAdder function:

function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12


Recursion-----------------------------------------------------------------------------------------------
-note return causes function to end theories
recursion: a method of solving a problem where the solution depends on the solutions to smaller instances of the same programmer
recursive function calls itself until it doesn't- needs a condition that stops the function from calling itself

1. the base case (terminating condition)
    the goal of our recursive function
    the conditions that stop the recursion
    can nest if statements
2. recursive case   
    the function called to change the input
    the function call to make the input
recursion is good when you have an undetermined number of loops

10/20/20______________________________________________________________________________________________________________________________________________________________
DATA STRUCTURES
JavaScript is a dynamic, loosely typed language
  variables are not associated with a specific variable type (int, float, etc.)
  let foo = 42 //is a number
  foo = 'bar'; foo is now a string
  foo = true; foo is now a boolean

Data types in js
string    'hello!'
number    23
boolean   true/false
object    {name: 'Javascript'}
array     
function
undefined
null

data structure - a particular way of organizing data in a computer so that it can be used effectiviely

linear data types (lists, queues, stacks)

binary search tree 

choose the right data structure
  how long to inser data? delete data? find data? sort data?

Time complexity - 
bit O Notation - describes the worst case (i.e. you are looking for last item in your list) performance of an algorithm or data structure in a relative way
O(n), O(n^2)  n is the size of the data
O(n) is linear, O (1) is flat, O(n!) is very computationally expensive
O(1) - constant time, no loops, no matter how big the input set is, the result will be returned in the same amount of time
O(n) - linear time, as input size increases, time to output increases linearly, a single loop
O(n^2) - polynomial time, as input set increases in size, increases at the square of that size
O(2^n) - exponential time, as input size increases, time to output increases linearly, a recursive call stack (fibonacci)
O(log n) - logarithmic time, as input increeases, time to output increases at a relative
O(n!) - factorial time

Big theta - average time
Big omega - best case time

Bubble Sort - O(n^2) sort segment of numbers low to high, swap 2 numbers if needed, repeat until complete (multiple itterations)
Binary search - O(log n) nodes, every time you check, number of things to check in the future goes down (at most have to check half of the elements)
fibonacci - O(n!) recursive function, occurs in nature often, (program fractal?)
  fibonacci number = all numbers less than n added together

paired activity - onto galvanize
Avery

1. Stack 
A stack works like a stack of plates -- plates are added and removed from the the top of the stack (LIFO: last in, first out).

push(element) - Add an element to the top of the stack
pop() - Remove and return the element on the top of the stack
size() - Return the number of items on the stack
peek() - Return the top element on the stack, but it won't remove it (the way pop() does)
isEmpty() - Returns whether or not the Stack is empty
printStack() - Prints all the elements of a queue
//implementing methods
class Stack {

    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }

    pop() {
        return this.items.pop();
    }

    size() {
      return this.items.length;
    }

    peek() {
      return this.items[this.items.length - 1]
    }

    isEmpty() {
      return this.items.length === 0;
    }

    printStack() {
     return this.items.join(' ');
    }
}



2. Queue 
A queue works like a line for an amusement park ride -- people enter at the end of the queue and leave from the front (FIFO: first in, first out).

A queue would be great for....
Issuing instructions to your sandwich-making robot.

enqueue(element) - Adds an element to the back of the queue
dequeue() - Remove and return the element at the front of the queue
size() - Return the number of items in the queue
front() - Return the element at the front of the queue
isEmpty() - Returns true or false whether the queue has elements
printQueue() - Prints all the elements of the queue

//queues
class Queue {

    constructor() {
        this.items = [];
    }

    enqueue(element) {
        return this.items.push(element);
    }

    size() {
      return this.items.length;
    }

    dequeue() {
     return this.items.shift(); //last element in array is first in the queue, has been there longest (for this instance)
    }

    front() {
        return this.items[0];
    }

    isEmpty() {
        return this.items.length === 0;
    }

 printQueue() {
     return this.items.reverse().join(' '); //need to reverse the array because the start of the queue is at the end of the array
     //first in first out
    }
}


3. Linked List 
A linked list is a dynamic data structure that allows for constant time insertion and removal at any point in the linked list (compare this to an array which on average has linear time insertion and removal operations). In exchange for this insertion and removal speed, linked lists are not indexed and any find operations on a link list require the linear time operation of traversing the entire linked-list from the beginning.

A linked list would be great for....
An itinerary you expect to add and remove destinations to and from.

.head property, a linkedListNode instance
.tail property, a linkedListNode instance
.addToTail() method, takes a value and adds it to the end of the list
.removeHead() method, removes the first node from the list and returns its value
.contains() method, returns boolean reflecting whether or not the passed-in value is in the linked list


//like making a class
var Node = (value) => {
  var node = {} //create the empty object

  node.value = value;   //add fields/key value pairs
  node.next = null;

  return node;  //passing back the node that was created
}

class LinkedList {  //when test code is calling, it populates the list

//this is how it looks before any values
  constructor() {
      var list = {}
      this.head = null;
      this.tail = null;
  }

  addToTail(value) {
      var newNode = Node(value);    //create new node
      if(this.head === null && this.tail === null) {    //check if there are any nodes
          this.head = newNode;
          this.tail = newNode;
      }
      else {
          this.tail.next = newNode  //have the old tail point to the newNode
          this.tail = newNode;  //set the new tail to newNode
      }
  }

  removeHead() {
    //var placeHolder = this.head.value;
        if (this.head.value === null)
    {
        return null;
    }
    else
    {
        var n = this.head.value;
        var head = this.head;
        var newHead = head.next;
        this.head = newHead;
        return n;
    }
  }

  contains(target) {
      var currentNode = this.head
      while(currentNode)
      {
          if(currentNode.value === target)
          {
              return true;
          }
          else{
              currentNode = currentNode.next;
          }
      }
      return false;
  }
}


4. Tree 
A tree is a hierarchical data structure consisting of a node (potentially) with children. The children are trees unto themselves, that is, nodes with (potential) children. For this reason the tree is referred to as a recursive data structure.

A tree would be great for....
Making a family tree.

A tree class, in functional with shared methods style, with the following properties:
.children property, an array containing a number of subtrees
.addChild() method, takes any value, sets that as the target of a node, and adds that node as a child of the tree
A .contains() method, takes any input and returns a boolean reflecting whether it can be found as the value of the target node or any descendant node
4
Tree -------- this is wrong here 

var Tree = function(value) {    //when a var is capitalized, it is like a class
  var newTree = {};
  newTree.value = value;

  // your code here
  newTree.children = [];  // fix me

    var extend = function(obj1, obj2) {
        for(var key in obj2) {
            obj1[key] = obj2[key]; //take properties from second object and adding to the first
        }
    }
    extend(newTree, treeMethods);
    return newTree;
};

var treeMethods = {};

treeMethods.addChild = function(value) {
    this.children.push(Tree(value));
};

treeMethods.contains = function(target) {
    if(this.value === target) {
        return true;
    }
    for(var i = 0; i < this.children.length; i++)
    {
      If(this.children[i].contains(target))
        {
            return true;
        }
    }
    return false;
};




5. Binary Search Tree 
Binary trees are trees that can only have 0, 1, or 2 children. Remember that trees are recursive data structures and therefore a tree's children are themselves trees and can each have 0, 1, or 2 children. In a binary search tree, one child (out of potentially two) will always be less than the node's value (based on whatever sorting condition you wish) and the other child will always be greater than the node's value. Whether it is the 'left' or the 'right' child which is greater or lesser is consistent throughout the binary search tree. This structure results in particularly fast find operations. You'll be asked to answer just how fast yourself.

A binary search tree would be great for....
A dictionary of all English words.

A .left property, a binary search tree (BST) where all values are lower than the current value.
A .right property, a BST where all values are higher than the current value.
A .insert() method, which accepts a value and places it in the tree in the correct position.
A .contains() method, which accepts a value and returns a boolean reflecting whether or not the value is contained in the tree.
A .depthFirstLog() method, which accepts a callback and executes it on every value contained in the tree.
var BinarySearchTree = function(value) {
  //TODO: IMPLEMENT THE ABOVE METHODS ON THE BST CLASS
  var newBinTree = {}
  newBinTree.left = null
  newBinTree.right = null
  newBinTree.value = value
  
  newBinTree.insert = function(value) {
      let node = this
      while (true) {
          if (value < node.value) {
              if (node.left === null) {
                  node.left = BinarySearchTree(value)
                  return
              } else {
                  node = node.left
              }
          } else if (value > node.value) {
              if (node.right === null) {
                  node.right = BinarySearchTree(value)
                  return
              } else {
                  node = node.right
              }
          } else {
              return
          }
      }
  }
  
  newBinTree.contains = function(value) {
      let node = this
      while (true) {
          if (value < node.value) {
              if (node.left === null) {
                  return false
              } else {
                  node = node.left
              }
          } else if (value > node.value) {
              if (node.right === null) {
                  return false
              } else {
                  node = node.right
              }
          } else {
              return true
          }
      }
  }
  
  newBinTree.depthFirstLog = function(cb) { //cb is a callback, it is a function being passed into this function
      function recurse(node) {
          if (node === null) {
              return
          }
          node.value = cb(node.value)
          recurse(node.left)
          recurse(node.right)
      }
      recurse(this)
      
  }
  
  return newBinTree
};



6. Graph 
Graphs consist of nodes (often referred to as vertices) and edges (often referred to as arcs) that connect the nodes. Unlike trees, graphs are not necessarily hierarchical. Graphs can be undirected, which means that the relationship of any 2 nodes connected by an edge is a symmetrical relationship, or they can be directed, which means there is an asymmetrical relationship between nodes that are connected by an edge.

Graph image

A graph would be great for....
Representing how a collection of websites (or the entire world wide web) link to each other, and many other things 


7. Set 
Sets contain unique values in no particular order.

Set image

A set would be great for....
A raffle, where all the tickets are unique and you just want to randomly pick one (or several) out of them all

------------------------------------------------------------------------------------------------------------------
Higher order functions
higher order function - a function taht takes a function (method) as a parameter, or returns a function after its execution

forEach()
  executes a provided function once for every array element - (for each object, etc)     object has key: value
  classList.forEach(function(person) {    //created an anonomous function, person is the input parameter, can be named anything
    console.log(person.name)
  })

.map()
  creates a new array populated with the results of calling a provided function on every element in the calling array
  const cityNames = classList.map(person => {
    return person.location; //pull out all locations into the new cityNames array (does not return anything else)
  });
  console.log(cityNames);

.filter()
  creates a new array with all elements that pass the test implemented by the provided function
  console.log(classList.filter(person => person.location ===('Chicago'))) will log all objects/array elements that meet Chicago location condition

.reduce()
  executes a reducer function (that you provide) on each element of the array, resulting in a single output value
  ex. want to add all elements of array to one value
  const personAges = classList.map(person => {
    return person.age;
  })  //created array of ages
  console.log(personAges);
  const reducer = (accumulator, currentValue) => accumulator + currentvalue;  //create your reducer,  currentvalue can be initialized but is updated for every pass of the array - they are all summed into the accumulator
  personAges.reduce(reducer); //after all values are used, the accumulator is returned (accumulator )

ex chaining
  classList.filter(value => {
    return value.location === ('Denver');
    }).map(person => {
      console.log(person.name);
    });

------solutions for datastructures will be posted


10/21/20______________________________________________________________________________________________________________________________________________________________
Pure functions






